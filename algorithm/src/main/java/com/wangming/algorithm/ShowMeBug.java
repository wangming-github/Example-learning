package com.wangming.algorithm;

// for i in range(3):
//   print('hello world')

// 必须定义 `ShowMeBug` 入口类和 `public static void main(String[] args)` 入口方法
// 题目：假设有一个计算器只能计算加法或乘法，其计算时间等同于每个数字乘以其索引值代入公式后的值。
// 比如 a + b 计算时间为 (a*1) + (b*2)；
// 计算 e + f * g 计算时间为 (e*1) + (f*2) * (g*3)；
// 计算 x * (y + z) 计算时间为 (x*1) * ((y*2) + (z*3))。
// 注：索引值为数字在公式中的位置，非字母序。

// 要求：输入公式和变量值，仅使用加法和乘法交换律，输出计算时间最小的等价公式
// 举例1:
//   输入：a + b, {a: 2, b: 3}
//   输出：b + a
//   说明：因为 a + b 计算时间为 2 * 1 + 3 * 2 = 8, b + a 计算时间为 3 * 1 + 2 * 2 = 7
// 举例2：
//   输入：a + (b + d) * c, {a: 5, b: 4, c: 3, d: 2}
//   输出：c * (b + d) + a
//   说明：a + (b + d) * c 计算时间为 (5*1)+((4*2)+(2*3))*(3*4)=173
//        c * (b + d) + a 计算时间为 (3*1)*((4*2)+(2*3))+(5*4)=62
// 请实现该程序，并编写测试用例证明。
// 时间：2小时，如来不及可在注释中提供思路。
public class ShowMeBug {

    static String optimize(String expression, java.util.Map<String, Integer> params) {
        //  a + b +( d + c +  e* f*(   z+ x+ c))
        // [a , b ,[ d , c ,[ e, f, [ z, x, c]]]]


        return expression;
    }


    /**
     * 注：在满足 “（）”，“*”，“+” 优先级的情况下，让数值大的值尽可能靠前这样去乘以其索引时得到等价公式时间最小
     * 一、数组内部排序
     * <p>
     * 1.a + b + d + c + e + f 若此公式只有一种算法 则此问题就是一个数组[a , b , d , c , e , f ]排序问题， 由大到小排序即可
     * 2.a + b + d + c + e * f 额外添加一种新的运算方法 ,则优先级较高的要被看作新的数组[a , b , d , c ,[ e , f ]]，
     * 两个数组 [a , b , d , c, [A]]与A: [ e , f ] 则此问题就是多个数组由大到小排序，然后将两个数字拼接
     * 3. a + b + （d + c + e * f）继续添加新的运算符号 思路与1，2相同，在原先基础上添加新的优先级数组 [a , b ,[ d , c ,[ e , f ]]]
     * 最终公式会呈现出一个多维数组的排序问题
     * <p>
     * 二、不同维度数组之间排序
     * <p>
     * [a , b ,[ d , c ,[ e , f, [ z, x, c] ]]]
     * --------------------------【④------】
     * -----------------【③----------------】
     * ---------【-②--------------------------】
     * 【----①----------------------------------】
     * <p>
     * 并且再次基础上每维数组我们需要计算出其①②③④每项“和”OR“平均值”（这里不太确定）将其数组当做一个值参与到其低一个维度的排序中
     * 这样④可能会出现在③数组的由大到小任意位置，③可能会出现在②由大到小的任意位置，以此类推
     * 任意长度的公式都可以得到时间最小的等价公式。
     */


    public static void main(String[] args) {
        System.out.println("Hello World!");
    }


}
