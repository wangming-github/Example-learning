package com.wangming.algorithm.sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;


public class Solution_4_Shell_Sorting_Review {


    /*
     * 描述：
     * 给定一个整数数组 nums，将该数组升序排列。
     * ————————————————————————————————————————————————————————————————————————————————————————————————————
     * 示例 1：
     * 输入：[5,2,3,1]
     * 输出：[1,2,3,5]
     *
     * 示例 2：
     * 输入：[5,1,1,2,0,0]
     * 输出：[0,0,1,1,2,5]
     *
     * 提示：
     * 1 <= A.length <= 10000
     * -50000 <= A[i] <= 50000
     *
     * 来源：力扣（LeetCode）
     * 链接：https://leetcode-cn.com/problems/sort-an-array
     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
     *
     * 执行用时 : 18 ms , 在所有 Java 提交中击败了 48.08% 的用户
     * 内存消耗 : 51.8 MB , 在所有 Java 提交中击败了 100.00% 的用户
     * ————————————————————————————————————————————————————————————————————————————————————————————————————
     * ————————————————————————————————————————————————————————————————————————————————————————————————————
     * 描述：希尔排序:
     * 在插入排序的基础上做了优化,调整数据位置，尽可能的让数组有序。
     *
     * 原始数组: [8, 9, 1, 7, 2, 3, 5, 4, 6, 0]
     *
     * 1. 将数组按照初始增量分为 gap = 10/2 = 5,按照步长为5，整个数组分成了 5 组:[8,3][9,5][1,4][7,6][2,0]
     *
     * [8, 9, 1, 7, 2, 3, 5, 4, 6, 0]
     *  ↑------①-------↑              [8,3]
     * [8, 9, 1, 7, 2, 3, 5, 4, 6, 0]
     *     ↑------②-------↑           [9,5]
     * [8, 9, 1, 7, 2, 3, 5, 4, 6, 0]
     *        ↑------③-------↑        [1,4]
     * [8, 9, 1, 7, 2, 3, 5, 4, 6, 0]
     *           ↑------④-------↑     [7,6]
     * [8, 9, 1, 7, 2, 3, 5, 4, 6, 0]
     *              ↑------⑤-------↑  [2,0]
     *
     * 2.对这【逻辑上】分开的5个组分别使用,上节所讲的【插入排序】
     *
     * [8,3][9,5][1,4][7,6][2,0]
     * 【插入排序】==>
     * [3,8][5,9][1,4][6,7][0,2]
     * 原始数组变成了:
     * [3, 5, 1, 6, 0, 8, 9, 4, 7, 2]
     *
     * 结果可以发现，这五组中的相对小元素都被调到前面了
     *
     * 3.缩小增量 gap = 5/2 = 2，按照步长为2，整个数组分成了 2 组:[3, 1, 0, 9, 7]; [5, 6, 8, 4, 2];
     *
     * [3, 5, 1, 6, 0, 8, 9, 4, 7, 2]
     *  ↑-----↑-----↑-----↑-----↑      ①[3, 1, 0, 9, 7]
     * [3, 5, 1, 6, 0, 8, 9, 4, 7, 2]
     *     ↑-----↑-----↑-----↑-----↑   ②[5, 6, 8, 4, 2]
     *
     * 2.对这【逻辑上】分开的2个组分别使用,上节所讲的【插入排序】
     *
     * [3, 1, 0, 9, 7] [5, 6, 8, 4, 2]
     * 【插入排序】==>
     * [0, 1, 3, 7, 9] [2, 4, 5, 6, 8]
     * 原始数组变成了:
     * [0, 2, 1, 4, 3, 5, 7, 6, 9, 8]
     *
     * 3.缩小增量 gap = 2/2 = 1，按照步长为1，整个数组分成了 1 组:[0, 2, 1, 4, 3, 5, 7, 6, 9, 8];
     * [0, 2, 1, 4, 3, 5, 7, 6, 9, 8];
     * 【插入排序】==>
     * [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
     * ————————————————————————————————————————————————————————————————————————————————————————————————————
     */
    public static int[] sortArray(int[] nums) {
        for (int gap = nums.length / 2; gap >= 1; gap = gap / 2) {//计算步长增量，并且逐步缩小增量
            for (int i = gap; i < nums.length; i++) {//从第gap个元素开始，逐个对其做的的组进行直接插入排序
                int j = i;
                int temp = nums[j];//将当前值存储起来
                while (j - gap >= 0 && temp < nums[j - gap]) {
                    nums[j] = nums[j - gap];//当前位置放前一个逻辑数组上的值
                    j -= gap;//减去步长
                }
                nums[j] = temp;
            }
        }
        return nums;
    }


    public static void main(String[] args) {
        int[] nums = new int[10];
        for (int i = 0; i < 10; i++) {
            nums[i] = (int) (Math.random() * 1000);//0~80000
        }

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS");
        System.out.println("排序前时间:" + simpleDateFormat.format(new Date()));
        System.out.println("排序前:" + Arrays.toString(nums));
        sortArray(nums);
        System.out.println("排序后:" + Arrays.toString(nums));
        System.out.println("排序后时间:" + simpleDateFormat.format(new Date()));
    }

}
