package com.wangming.algorithm.sort;

/**
 * 算法的时间复杂度
 *
 * @version V1.0
 * @auther MaiZi
 * @date 2019-09-06 14:10
 */
public class Solution_0 {


    /**
     * 算法的时间复杂度:
     * 时间频度: T(n)
     * （1）时间频度一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。
     * 但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。
     * 并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。
     * 一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。
     * （2）时间复杂度:O(f(n))
     * 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),
     * 使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。
     * 记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。
     * 在T(n)=4n²-2n+2中，就有f(n)=n²，使得T（n)/f(n)的极限值为4，那么O(f(n))，也就是时间复杂度为O(n²)
     * <p>
     * 1) 一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 T(n)表示，
     * 若有某个辅 助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n)是 T(n)的同数量级函数。
     * 记作 T(n)=O( f(n) )，称O( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。
     * 2) T(n) 不同，但时间复杂度可能相同。 如:T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的 T(n) 不同，但时间复杂 度相同，都为 O(n²)。
     * 3) 计算时间复杂度的方法:
     *  用常数 1 代替运行时间中的所有加法常数: T(n)=n²+7n+6 => T(n)=n²+7n+1
     *  修改后的运行次数函数中，只保留最高阶项: T(n)=n²+7n+1 => T(n) = n²
     *  去除最高阶项的系数: T(n) = n² => T(n) = n² => O(n²)
     * <p>
     * 最坏时间复杂度:
     * 1) 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。
     * 2) 最坏情况下的时间复杂度称最坏时间复杂度。
     * 一般讨论的时间复杂度均是最坏情况下的时间复杂度。
     * 这样做的 原因是:最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。
     * 3) 平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。
     */

    /**
     * 算法的空间复杂度简介
     * 1) 类似于时间复杂度的讨论，一个算法的空间复杂度(SpaceComplexity)定义为该算法所耗费的存储空间，它也是 问题规模 n 的函数。
     * 2) 空间复杂度(SpaceComplexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的 临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例 如快速排序和归并排序算法, 基数排序就属于这种情况
     * 3) 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品 (redis, memcache)和算法(基数排序)本质就是用空间换时间.
     * <p>
     * 算法优化 ==> 空间换时间
     */

    //计算1-100和：T(n)=n+1;
    public void sum_1() {
        int total = 0;
        int end = 100;
        for (int i = 1; i <= end; i++) {
            total += i;
        }
    }

    //计算1-100和：T(n)=1;
    public void sum_2() {
        int total = 0;
        int end = 100;
        total = (1 + end) * end / 2;
    }


    /**
     * 7.3.4 常见的时间复杂度
     * 1) 常数阶O(1)
     * 2) 对数阶O(㏒2n):log以2为低N的对数
     * 3) 线性阶O(n):
     * 4) 线性对数阶O(n㏒2n)
     * 5) 平方阶O(n²):嵌套循环
     * 6) 立方阶O(n³):三层循环
     * 7) k次方阶 O(n^k):K层循环
     * 8) 指数阶O(2^n):！！！需要避免
     * 说明:
     * 1) 常见的算法时间复杂度由小到大依次为:Ο(1)<Ο(㏒2n)<Ο(n)<Ο(n㏒2n)<Ο(n^2)<Ο(n^3)< Ο(n^k) < Ο(2^n) ，
     * 随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低
     * 2) 从图中可见，我们应该尽可能避免使用指数阶的算法
     */

    //1) 常数阶O(1) 只要没有循环等复杂的结构，那这个代码的复杂路就是O(1)
    public void O_1() {
        int i = 1;
        int j = 1;
        ++i;
        j++;
        int m = i + j;
    }

    //2) 对数阶O(㏒2n):log以2为低N的对数
    public void O_2(int n) {
        int i = 1;
        while (i < n) {
            i = i * 2;
        }
    }

    //3) 线性阶O(n):
    public void O_3(int j, int n) {
        for (int i = 1; i < n; ++i) {
            i++;
            j = i;
        }
    }

    //4) 线性对数阶O(n㏒2n)
    public void O_4(int j, int n) {
        for (int m = 1; m < n; ++m) {
            int i = 1;
            while (i < n) {
                i = i * 2;
            }
        }
    }

    //5) 平方阶O(n²):嵌套循环
    public void O_5(int i, int n, int j) {
        for (int m = 1; i <= n; m++) {
            for (i = 1; i <= n; i++) {
                j = i;
                j++;
            }
        }
    }

}
